# File: Bucky.txt
# Author: Bucky Frost
# Purpose: CS 372 Project 1 Diary

Entry 0x01
Mon Mar  3 02:53:02 AKST 2014
For project meeting on 2014/02/28

	The project started off by meeting during class time to come up with
	user stories in the spirit of Agile and Scrum software development for
	designing a Battleship program.	Dustin Dodson, my project teammate, and
	I spent the hour amongst our fellow classmates brainstorming and 
	committing desired stories to index cards.

	This was quite the exciting time! Ideas were flying between the
	project groups a breakneck pace. One group would consider one feature
	only to decide against it, while another group would take that idea
	and incorporate it into their own project in some manner. All the
	while, professor Hartman would move between the groups and provide
	insight into the process, or emphasize on points from lectures. It 
	was quite the social experience that most of the CS classes did not
	share. One of the best lecture periods during my college career.

	Dustin and I work in the manner of trying to involve a client in the
	feature design. This mostly took the form of one of us providing a leading
	prompt and have the other pick out the desired features from the
	question. For example, I would ask "What kinda interface do you want
	the game to be?" Dustin would then reply that he thought a text based
	game would be good for a start.

	In hind sight, this is not quite the way to pose questions to a
	client. As this type of questioning would lead them into the thoughts
	of how the implementor sees the problem. A more appropriate means for
	flushing out the expectations of a client would be more in tune to
	questions posed as "What do you want to see when you open your game?"
	Know what they say, haven't tried anything new if you don't make
	mistakes.

	At the end of the hour, we had wrote about 15 user stores between the
	both of us. We both noticed that most of the cards contained high
	level ideas about the game. It would make assigning timings and
	complexity rating to the stories difficult. We there for decided to
	communicate over email to setup a meeting over the weekend to break
	down the stories into smaller stories and assign the ratings then.


Entry 0x02
Mon Mar  3 04:41:02 AKST 2014
For project meeting on 2014/03/01

	Over email, Dustin and I decided to meet in the CS lab at 1600 for
	flushing out the user stories. We organized them based on a progress
	of the usual use case of the Battleship game. Having decided that the
	game will be text based, the menus of the game should be created
	first. From there, an automatically generated board and layout should
	be presented for two human players to engage at the same computer can
	dual each other. We now had a progression of user stories that we
	wanted to implement first. 

	We decided to have the first user story, making menus, would be used
	as a means to judge the rest of the user stories in complexity as it
	was the first story to implement. We also used the first story as a
	means to provide a sense of how much time should be attributed to each
	story.

	Thus, our first sprint was to make the menu, add some music tracks to
	it, get the underlining system implemented, give the player controls, 
	and then allow them the play a game. At	this point we agreed that the
	index cards containing the user stories should be transfered to a
	Google doc for us both to have access to. Since I've already started
	on a slide deck for this I agreed to type up the cards. By this time
	the meeting had ran approximately an hour. We decided to call it a day
	as we had other assignments to get to. Before leaving we agreed to 
	meet regularly at the CS lab on Monday and Wednesday at 1900 to pair
	program the game.


Entry 0x03
Mon Mar 24 01:39:05 AKDT 2014
For project meeting on 2014-03-04
Based of the Git commit history.

	Dustin and I have started on the project in earnest. We decided that
	we should pair program the majority of the project. Starting off on
	the first story of the main menu. We have it in its separate file
	menus.cpp. We were thinking of having all the different functions for
	the printing of the menus, main, pause, options, etc. defined in here.
	
	Dustin wanted to focus on a cross platform game. So we got a file
	defined to hold these functions that would be OS specific. Hence,
	osFunctions.cpp. The functions defined in here thus far are the clear
	screen function to help keep the output of the game to the console
	pretty.

	Dustin came to the meeting with a means to get the sound working
	already. Still going for the cross platform compatibility, he chose
	IrrKlang to implement the sound. He had some previous experience
	working with sounds in other projects, so I let him take point on it.

	So we got the two menus coded up, the main and the pause. Dustin drove
	while I would add in suggestions here and there. After that, Dustin
	suggested that we should make a sound class that would serve as a
	wrapper to the IrrKlang. Which was an excellent idea given that the new
	interface to the sound would allow us to change the implementation if
	we so chose to. Nice way to abstract away from the dependency on
	IrrKlang. 

	The class went into Sound.cpp. We got a constructor, destructor, with
	pausing and resuming. Have a simple siren file that we could test
	this out on. Worked like a champ. 

	The only thing during this time is that we were making multiple
	changes to the files between Git commits. I had some trouble speaking
	up to make so of the suggestions to make some commits as I was working
	with a new partner and didn't want to step on toes or break the flow
	of the programming. Should have been something that I brought up
	during one of our times working together. However, over the course of
	the project we became comfortable working with each other and this
	didn't turn into an issue. Need to be able to pace the flow the code
	creation and do a commit to keep documentation on our thoughts of the
	code we are making. Also, need to make sure that I prompt when I feel
	that there should be a commit. 

	After we got the sound working we decided to call it. After that I
	decided to maintain a spreadsheet of our times to make sure that we
	spent enough time on the project on a Google doc that would be shared
	between us.


Entry 0x04	
Mon Mar 24 02:25:42 AKDT 2014
For project meeting on 2014-03-04
Based mostly off the Git commit logs.

	This was the 4th meeting. We already had a some menus and the sound
	working. So, as the project owners we decided that we would want to
	see the results of the progress of the coding. Therefore, we would
	get the board for the game up and running so that we could tack on the
	features of the game and be able to show off the work that we got
	working.

	Wanting to keep the project small and then slowing expand the
	features, we decided to start with the traditional version of the
	game. We had some constants for the size of the board (I thing its
	10x10). Also, it was decided to use a vector as the underlining data
	structure for the board so that we could easily manipulate the board
	in the future. The vector was initially of a type of vectors of bools,
	just to simply tell if there was a ship there or not. This gets 
	changed later in the project.

	Our initial default constructor would simply set the constant that
	would be the board size. We also had an initializer to add the 'rows'
	of the board to the 2D vector, initialized to false. We were using the
	push_back function. But after reading about the emplace_back function
	which constructs the object on the call instead of copying this could
	clean up the code by getting rid of the temporary variable. However, 
	this is the first version so I can't remember if this gets changed.

	Our next function that we defined was the isOccupied. This would
	simply tell use if there was a bit of the ship at that particular
	coordinate on the board. Our initial implementation was using a two
	separate ints for the x and y to index the board. Thankfully this gets
	changed latter on. Hurray for monotonic functions!

	After having the getter for the board data, we decided we need to be
	able to see what we were doing with the board. Therefore, printBoard
	was implemented. We wanted to keep the cell like structure of the
	board, so we had some ASCII to show off the columns and rows of the
	board. There was one helper function that made to help keep the print
	board function cleaner, this function getEndString would just provide
	the strings to cap off the top and bottom of the board. In hindsight
	this could have been called something else more relating to the board.
	Anyway...

	After getting this working we wanted to print if there was ship there
	or not. So we made function getMidString that would return a string
	for the row of the board with an F for an empty cell or a T for a
	ship. Ternary operators are awesome for this, always being used in
	user interfaces in some way.

	Here was our first and only attempt at using Test Driven Development
	(TDD). We simple threw together a cpp file using the Catch testing
	framework. We added in some lines to provide some test cases for the
	isOccupied function of the board. In retrospect, I think we didn't
	use TDD heavily due to wanting to keep implementing features of the
	game. Also, it might have to do with its harder to think of the
	features in terms of the tests that you want to do. Maybe it just that
	tests don't make nice chunks that we were use to coding in one
	sitting.

	At this point we had a means to print the board and some tests, we
	called it a day.
